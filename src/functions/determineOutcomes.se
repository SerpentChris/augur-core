# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]

EVENTS = self.controller.lookup('events')
extern events: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, addReportersPaidSoFar:[int256]:int256, getBond:[int256]:int256, getChallenged:[int256]:int256, getCreationTime:[int256]:int256, getEarlyResolutionBond:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getEventResolution:[int256]:bytes, getExpiration:[int256]:int256, getExtraBond:[int256]:int256, getExtraBondPoster:[int256]:int256, getFirstPreliminaryOutcome:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForkResolveAddress:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getMode:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportersPaidSoFar:[int256]:int256, getReportingThreshold:[int256]:int256, getResolutionAddress:[int256]:int256, getResolutionLength:[int256]:int256, getResolveBondPoster:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setChallenged:[int256]:int256, setController:[int256]:int256, setCreationTime:[int256]:int256, setEarlyResolutionBond:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setExtraBond:[int256,int256]:int256, setExtraBondPoster:[int256,int256]:int256, setFirstPreliminaryOutcome:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setMode:[int256,int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, suicideFunds:[int256]:_]

extern subcurrency: [allowance:[address,address]:uint256, approve:[address,uint256]:uint256, balanceOf:[address]:uint256, decimals:[]:uint256, name:[]:uint256, symbol:[]:uint256, totalSupply:[]:uint256, transfer:[address,uint256]:uint256, transferFrom:[address,address,uint256]:uint256]

inset('../macros/refund.sem')
inset('../macros/eventHelpers.sem')
inset('../macros/float.sem')

data controller

macro INDETERMINATE: 1500000000000000000

### Serves to resolve events

# Resolves a binary market
def init():
    self.controller = 0x0

# Determines the "winning outcomes" for a given market/event
# Easiest to give examples:
    # 1D Markets:
        # Binary or Categorical will have 1 winning outcome [1 or 2 for binary, 1 thru numOutcomes for categorical is the poss. value for the winning outcome]
def determineWinningOutcomes(event):
    winningOutcomes = array(8)
    fxpOutcome = EVENTS.getOutcome(event)
    outcome = fxpOutcome / ONE
    # scalar or .5
    if(scalar(event) or fxpOutcome == INDETERMINATE):
        winningOutcomes[0] = 1
        winningOutcomes[1] = 2
    # anything besides scalar or .5
    # note: this will be the outcome in the middle if a categorical is resolved as indeterminate, it'll still payout 1/n per outcome though
    else:
        winningOutcomes[0] += outcome
    return(winningOutcomes: arr)

def setController(newController):
    if(msg.sender != self.controller):
        ~invalid()
    self.controller = newController
    return(1)

def suicideFunds(to):
    if(msg.sender != self.controller):
        ~invalid()
    suicide(to)